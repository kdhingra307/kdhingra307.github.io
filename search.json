[
  
    {

      "title"    : "",
      "url"      : "/posts/2023-04-05-Git-sync-with-the-help-of-a-shell",
      "content"  : ""

    },
  
    {

      "title"    : "Colorization - Sampling Color from GrayScale and I.R. Images",
      "url"      : "/notes/study-of-colorization",
      "content"  : "Given a grayscale image, it is a daunting task, even for a human, to visualize it in color. See Figure 1 for examples. However, a human may try to find semantic clues like texture and world knowledge to assign colors to objects. For example, the grass is mostly green, or the sky is mostly blue. But these clues may also fail sometimes, as shown in Figure 1(middle). Thus, in this work, the focus was on assigning a plausible set of colors to the Image, which may or may not be the same as the ground truth.\n\n\n\nFig:1 GrayScale Images and Corresponding Color\n\n\n  The primary motivation behind pursuing this problem was that many images do not have color information. Also, the problem of Colorization is self-supervised and does not require a pair-wise dataset.\n\n\nThe aim is to solve it in generative fashion, such that if we feed the same grayscale Image to the network k times, it may generate different output each time. A generative network’s benefit is that it may color the cloth’s stripes (Figure 2), gray or red.\n\n\n\nFig:2 Plants in the left Image are entirely green, not in the right\n\nThe solution is based on PixColor, which is state of the art autoregressive generative neural networks for Colorization, i.e., the output of $i^{th}$ pixel is not just conditioned on the latent representation of the grayscale Image, X but also on the previous outputs, $[i-t, i-t+1, i-t+2\\ …\\ i-1]$ where t denotes the receptive field.\n\nGiven $X \\in [H, W]$, we first extracts the features $Y_1$ using Resnet-101 of size $[\\frac{H}{4}, \\frac{W}{4}, 1024]$. These features are then passed into an adaption network and use three convolution layers to adapt the features required by pixelcnn. The output from the adaption network is of size $[\\frac{H}{4}, \\frac{W}{4}, 64]$, and is fed into conditional pixelcnn. It masks the weights of a convolutional layer to prohibit pixel $x_i$ from using any information about the future samples $(x_{i+1:N})$.\n\nTraining is the same as that of any other end-to-end trainable architecture (as ground truth data was used under teacher training mechanism), but during testing, for each pixel $i$, the class is sampled from a multinomial distribution defined by the softmax output of the network.\n\n\nFig:3 Result of Colorization Algorithm\n\nThe first seven images in carousal(at the top) are the PixColor algorithm results with key insights from each of the Images.\n\nExtension towards I.R. images\n\nI decided to continue working on image colorization during my next semester, focusing on ​reducing the artifacts and ​improving larger objects’ coloring​. The output from pixelcnn is given to a fully convolutional network, acting as a denoiser, inspired by Tacotron, a source synthesis architecture.\n\nFig:4 Correction of Green Artifact as shown in left Image\n\nAfter that, my professor suggested applying image colorization on I.R. images. In applications under low lighting, I.R. cameras come in handy, but interpreting I.R. images is not straightforward for a human, and hence translating to RGB improves its understandability. I.R. images introduced two challenges, i) it is no longer a self-supervised task and requires a parallel dataset, ii) it is computationally expensive since with grayscale images, we can learn the color information at less spatial resolution(Figure 5-middle) and upscale it, with minimal impact on visual quality but with I.R. images, we need to learn Luminicance too(Figure 5-bottom).\n\n\n  \n    \n      Input Image\n      \n    \n  \n  \n    \n      Color channels downscaled and Interploated\n      \n    \n    \n      All channels are downscaled and interpolated\n      \n    \n  \n\n\nFigure 5: Effect of downsampling on image quality\n\nFor I.R. to RGB, I did not directly use PixelColor to generate color images but first used ImageGAN with wassterin loss. It ended up being blurry because we were averaging the loss over all of the pixels (Table - 1).\n\n\n  \n    \n      Input - IR\n      Target - RGB\n      Output - RGB\n    \n  \n  \n    \n      \n      \n      \n    \n    \n      \n      \n      \n    \n  \n\n\nTable:1 Blurry Output when GAN’s are not used\n\nAn I.R. image is first passed through GAN, which generates grayscale output followed by PixColor for sampling RGB from the generated grayscale.\n\n\n  \n    \n      Input I.R.\n      Target GrayScale\n      Generated GrayScale\n    \n  \n  \n    \n      \n      \n      \n    \n    \n      \n      \n      \n    \n    \n      \n      \n      \n    \n    \n      \n      \n      \n    \n    \n      \n      \n      \n    \n    \n      \n      \n      \n    \n  \n\n\nTable 2: Output of ImageGAN\n\nThe ImageGAN model produced close to ground truth for many situations (Table 2 first four rows). Still, the model’s performance deteriorated when uncommon objects were present in the I.R. image, like a person on the cycle or person themselves, highlighting the importance of richer data sources.\n\nThe last five images in carousal(at the top) are the results of the I.R. to color algorithm with key insights from each of the Images.\n\nDatasets\n\nThe ADE20K  scene parsing dataset was used for PixColor training; it has 20K training and 1.5k validation samples. Also, there was a pretrained resnet101 network, which helped speed up the training process.\nFor I.R. to RGB translation, the kaist multispectral benchmark was used. It is divided into multiple files, with each file consisting of over 10000 images, but it lacks the spatial resolution. I tested six different datasets that have pair-wise I.R. and RGB images and found it to be most aligned.\n\nTraining and Analysis\nPixColor was trained for 50 epochs, in 100% teacher-training mechanism, i.e. during training pixelcnn autoregressive considers ground truth samples as previous t inputs. The ImageGAN was trained for 150 epochs, I stopped after 150 epochs due to computation constraints. Evaluating generative models is very hard, that’s why I tested the color distribution generated by the PixColor and observed biases towards the brown color which was present in the ADE20k data itself.\n\n\n\nCurrently, I am studying more about GANs to train them effectively with fewer data points, if you have any questions or suggestion, please let me know on Twitter or instagram.\n\nReferences\n\n  Guadarrama, Sergio, et al. “Pixcolor: Pixel recursive colorization.” arXiv preprint arXiv:1705.07208 (2017).\n  Salimans, Tim, et al. “Pixelcnn++: Improving the pixelcnn with discretized logistic mixture likelihood and other modifications.” arXiv preprint arXiv:1701.05517 (2017).\n  Oord, Aaron van den, et al. “Conditional image generation with pixelcnn decoders.” arXiv preprint arXiv:1606.05328 (2016).\n  Zhou, Bolei, et al. “Scene parsing through ade20k dataset.” Proceedings of the IEEE conference on computer vision and pattern recognition. 2017.\n  Hwang, Soonmin, et al. “Multispectral pedestrian detection: Benchmark dataset and baseline.” Proceedings of the IEEE conference on computer vision and pattern recognition. 2015.\n  Wang, Yuxuan, et al. “Tacotron: Towards end-to-end speech synthesis.” arXiv preprint arXiv:1703.10135 (2017).\n  Arjovsky, Martin, Soumith Chintala, and Léon Bottou. “Wasserstein generative adversarial networks.” International conference on machine learning. PMLR, 2017.\n  Isola, Phillip, et al. “Image-to-image translation with conditional adversarial networks.” Proceedings of the IEEE conference on computer vision and pattern recognition. 2017."

    },
  
    {

      "title"    : "How does tree metrics works",
      "url"      : "/notes/tree_metrics_in_detail",
      "content"  : "Comparing MLTED, RF distance, and TreeVec\n\nMLTED\n\n\n  \n    \n      \n      \n    \n  \n  \n    \n      Tree 1\n      Tree 2\n    \n    \n      \n      \n    \n    \n      Tree 3\n      Tree 4\n    \n    \n      \n      \n    \n    \n      Tree 5\n      Tree 6\n    \n  \n\n\nOn comparision of tree 1 with tree3 and 4, the output from MLTED was 100% similarity and 0 edit distance with the normalized output as 1. Even though Tree(1) as only three nodes while others have many more. It is because Tree(1) is lacking information which other trees have but there is no error in the output which needs to be corrected. When the comparison is made between Tree(2) and Tree(1, 3, 4), edit distance of 14 was found in each case and similarity of 3 because only three nodes are common (a, b, c) in any pair and Tree(2) on the one hand is projecting taxa(b, c, d) as independent (parallel) while in other trees these three mutations happens simultaneously. Tree(5) deals with the condition when one tree shows different order of mutation than the other, while Tree(6) addons to Tree(5) by replacing the root with some other elements.\n\n  Tree(5)\n    \n      With Tree(1)\n  100% similarity(of 10), as already described.\n      Tree(2)\n  Similarity of 3, as already described.\n      Tree(3)\n  Similarity of 9, and edit distance of 2. It is because 9 nodes are in correct position out of 10 (h is not in). 1 distance is required to remove h, and other to add it as child of g.\n      Tree(4)\n  Similarity of 4, as we have shuffled nodes.\n    \n  \n  Tree(6)\n    \n      \n        With Tree(1)\n\n        Similarity of 8 and distance of 4,\n        \n          1 to remove a from b node.\n          1 to remove g from the b node.\n          1 to add b as child of a.\n          1 to add g as child of a.\n        \n      \n    \n  \n\n\nThe final score can be calculated in two ways, $\\frac{similarity}{num_nodes}$, or $\\frac{edit_distance}{2*num_nodes}$.\n\nRF metric,\nIt is implied by sum of two terms, A+B where A represents number of partition of data implied by $T_1$ but not $T_2$, while B represents versa. RF metric ensures that we have exact ordering of taxas in tree whereas MLTED only ensured that nodes(can contain multiple taxas) are in correct order.\nIt is not possible to compare the trees present in the above tables, as RF metric requires same set of leaf nodes in the tree. Therefore, table given below will help in better understanding of RF metric.\n\n\n  \n    \n      \n      \n    \n  \n  \n    \n      Tree 1\n      Tree 2\n    \n    \n      \n      \n    \n    \n      Tree 3\n      Edges Labelled\n    \n  \n\n\nIn RF distance, we are required to calculate the sum of splits which are present in tree 1 but not tree 2 and vice versa. Therefore using the edge labelling (in red color). We define split of each tree (q split is not required as it would be same as that of x) as\n\n\n  \n    \n      Tree 1\n      Tree 2\n      Tree 3\n    \n  \n  \n    \n      C(x)ABD\n      C(x)ABD\n      B(x)ACD\n    \n    \n      D(y)ABC\n      B(y)ADC\n      C(y)ABD\n    \n    \n      B(z)ACD\n      D(z)ACB\n      D(z)ACB\n    \n    \n      A(r)BCD\n      A(r)BCD\n      A(r)BCD\n    \n    \n      BD(p)AC\n      BD(p)AC\n      CD(p)AB\n    \n  \n\n\nThe splits between Tree(1) and Tree(2) as it does not matter which branch splits it because of being unrooted. While there are two unique splits in case of Tree(3) and Tree(1) or Tree(2). Thus, RF distance would be 2 in this case. If needed normalization then it is done by dividing it with total number of splits presents in both of the tree. Therotically, we are not bounded by comparing tree which does not have same number of leaves but tools does not allow.\n\nTreeVec\nIt is also a metric for unrooted tree, and is primarly to pool different taxas based on their context. Basically, if the tree has leaf nodes as ${a_1, a_2, b_1, b_2}$. It implies $a_1, a_2$ belongs to category a while $b_1, b_2$ belongs to category b. No other method can help in this case. So, this method is very trivial.\nCalculates minimum depth from root(can be assigned to any node) to pair of leaf nodes.\nTake mean of all depths for all categories.\nCompute Eucledian distance between all of the categories for all of the trees.\n\n\n\n  \n    \n      \n      \n    \n  \n  \n    \n      Tree(1)\n      Tree(2)\n    \n  \n\n\nIn this example, there are no examples in the subcategories.Minimum depth for each pair of the nodes is presented in the table below.\n\n\n  \n    \n      Pair\n      Tree(1)\n      Tree(2)\n    \n  \n  \n    \n      $a \\to b$\n      0\n      1\n    \n    \n      $a \\to c$\n      0\n      2\n    \n    \n      $a \\to d$\n      0\n      2\n    \n    \n      $a \\to e$\n      0\n      0\n    \n    \n      $b \\to c$\n      1\n      1\n    \n    \n      $b \\to d$\n      1\n      1\n    \n    \n      $b \\to e$\n      1\n      0\n    \n    \n      $c \\to d$\n      2\n      3\n    \n    \n      $c \\to e$\n      2\n      0\n    \n    \n      $d \\to e$\n      3\n      0\n    \n  \n\n\nThus, final distance is calculated between these two vectors (eucleadian in this example), 4.89."

    },
  
    {

      "title"    : "Basics of Phylogeny",
      "url"      : "/notes/basics_of_clonal_evolution",
      "content"  : "Phylogeny\n\nGiven a VAFs, the task is to generate ancestoral tree such that it adheres to the principles of perfect phylogeny.\n\nTerminology\n\n  M matrix of size $(m, n)$ denotes the presence of $m^{th}$ mutation in $n^{th}$ location of the tumor.\n  V matrix of size $(m, n)$ represents VAFs of $m^{th}$ sample in $n^{th}$ location of the tumor.\n  T tree, provides the ancestoral representation of mutations based on phylogeny of M matrix.\n  Character, represents the language of mutation and in our case T or A denoting whether Tumor has been found at a particular site or not.\n\n\nPerfect Phylogeny\n\n  A phylogeny tree is perfect if it follows the following principle,\n\n\n\n  Mathematically, there should be no conflict between the mutations at any two sites.\n\n\n\\[Conflict (i, j) = \n    \\begin{cases}\n        true, &amp; \\text{} M[k, j] \\nleqslant M[k, i], M[k, j] \\ngeqslant M[k, i], \\forall k \\in m.  \\\\\n        &amp;\\text{} M[k, j] = M[k, i], \\exists k \\in m.  \\\\\n        false, &amp; otherwise\n    \\end{cases}\\]\n\n$\\quad$ for example,\n\n\\[M = \\begin{bmatrix}\n    1&amp;0&amp;0&amp;0\\\\\n    1&amp;1&amp;1&amp;0\\\\\n    0&amp;0&amp;0&amp;1\\\\\n    0&amp;1&amp;0&amp;0\n\\end{bmatrix}\\]\n\n$\\quad$ Column 1 and 2 in Matrix, M are in conflict while column 3 and 4 are not.\n\n\n  \n    Intutively, it is because we can say that that column 3 is ancestoral clone of column 2 but we cant say the same for column 1 and 2. While with column 3 and 4, we can say these are not ancestoral clones.\n  \n  \n    Perfect Phylogeny, also ensures the invention of new character[1] is a rare events and does not happen in multiple sites across the phylogeny tree.\n  \n\n\nGeneration of Evolutionary tree from Perfect Phylogeny\nGiven M, which has no conflict present in the columns, finding ancestors required as to\n\nInput : M\n\nfunction(map)\n\nfunction(M):\n    sort(M) over columns.\n    append($C_0$, M), where $C_0 \\in \\{0\\}.$ \n    for $C, C'$ in columns, where $C' \\ne C$:\n        if $C' \\subseteq C$ then\n            draw an edge in T from $C \\to C'$;\n    \n\n    for each_node in T:\n        get(characters required)\n        check : any row uses these characters\n        if yes:\n            label node as that row.\n\n\nExample:\n\n\\[M = \\begin{bmatrix}\n0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;1\\\\\n0&amp;0&amp;0&amp;0&amp;0&amp;1&amp;0\\\\\n0&amp;0&amp;0&amp;0&amp;1&amp;1&amp;0\\\\\n0&amp;0&amp;0&amp;1&amp;0&amp;0&amp;0\\\\\n0&amp;0&amp;1&amp;0&amp;0&amp;0&amp;0\\\\\n0&amp;1&amp;1&amp;0&amp;0&amp;0&amp;0\\\\\n1&amp;1&amp;1&amp;0&amp;0&amp;0&amp;0\n\\end{bmatrix},\nM_{sorted} = \n\\begin{bmatrix}\n1&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;1\\\\\n1&amp;0&amp;0&amp;1&amp;0&amp;0&amp;0&amp;0\\\\\n1&amp;0&amp;0&amp;1&amp;0&amp;0&amp;1&amp;0\\\\\n1&amp;0&amp;0&amp;0&amp;0&amp;1&amp;0&amp;0\\\\\n1&amp;1&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0\\\\\n1&amp;1&amp;1&amp;0&amp;0&amp;0&amp;0&amp;0\\\\\n1&amp;1&amp;1&amp;0&amp;1&amp;0&amp;0&amp;0\n\\end{bmatrix}\\]\n\n\n  \n    \n      \n      \n    \n  \n  \n    \n      Tree with nodes representing columns\n      Tree with nodes representing mutation, and Yellow color nodes representing derived mutation\n    \n  \n\n\nImportance of VAFs in phylogeny\n\n\n  \n    \n      \n      \n    \n  \n  \n    \n      Tree with nodes representing columns\n      Tree with nodes representing mutation, and Yellow color nodes representing derived mutation\n    \n  \n\n\nWhen we added VAFs information to the mutations, we were able to infer inner relationship between the nodes which got lost with binary representation of M matrix.\n\nMaximum Parsimony\n\n  In real world experiments, we are not gurranteed to get perfect phylogeny from the sequencing, and that’s where the principle of maximum parsimony plays its role.\n  Our aim is to generate parsimonious tree from the input data, i.e. a tree which can represent the M matrix in the best possible representation.\n  Algorithm (It uses distance based clustering for generation of tree, and Fitcher’s small parsimony principle for labeling of derived clones)\n    Create a separate cluster for each node.\nIteratively(till we have only one cluster left):\n  Given all of the clusters,\n  merge two clusters which has the minimum distance.\n    \n    where\n\n\\[distance(a, b) = \\frac{distance(a) + distance(b)}{2},\\]\n\n    and initial distance between two clones are calculated as the edit distance between two clones.\n  \n\n\nGiven : Tree\nAt first,\n    In bottom up fashion, for each location(k) of node i,$$\n            Cn_i^k = \\begin{cases}\n            \\cup(Cn_j^k) &amp; if \\cap(Cn_j^k) = \\phi, where\\ n_j = child(n_i)\\\\\n            \\cap(Cn_j^k) &amp; otherwise\\\\\n            \\end{cases}\n            $$\n            In the top down fashion, for each location(k) of node i,$$\n                Cn_i^k = \\begin{cases}\n                Cn_i^k = Cn_j^k &amp; if Cn_j^k \\in Cn_i^k, where\\ n_j^k = parent(n_i^k)\\\\\n                Cn_i^k = random(Cn_i^k, 1) &amp; otherwise\n                \\end{cases}\n            $$\n\n\nMixPhy\n\n  With Fletcher’s Algorithm and Agglomerative clustering, we aimed to find the best parsimonious tree from the M but it does not takes into the account key factors that clones in M might have been mixed.\n  That’s where the problem of Maximum parsimony comes into account. The problem states that we have to find the best steiner tree from the input M.\n  MixPhy solved this Np-hard problem heuristically by restructing the input as a perfect graph and coloring rows which will get split into multiple clones.\n  Algorithm\n    \n      For the given M, create a graph, G in which two columns are connected if either one is contained in another.\n  where, contained is defined as if all of the element are either $\\leq$ or $\\geq$.\n      As the containment is a transitive in nature,\n      i.e. if {0, 0, 1} is contained in {0, 1, 1} and {0, 1, 1} is contained in {1, 1, 1} then {0, 0, 1} is also contained in {1, 1, 1}\n      Thus the output graphs becomes perfect in nature, and the problem of finding cliques becomes polynomially complex.\n      If we observe the complement of G is the conflict graph in which any two columns are connected if both are conflicting in nature.\n      Thus coloring a clique of graph G, with the same color will lead to no two adjacent columns having the same color in the conflict graph.\n      and for each row in M:\n  if color of all of the mutated column is same, then we do not need to split it\n  otherwise it will get splitted into k different rows where k are the number of unique colors required to color that row."

    }
  
]
